## 绪论

面向对象四个特点：**抽象**、**封装**、**多态**、**继承**
类型大小：byte
- char: 1
- short: 2
- int: 4
- long: 4
- long long: 8
- float: 4
- double: 8
---
## 简单程序设计

#### 常量
常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

#### 变量
---
## 函数

#### 什么是内联函数？
如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。
对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。
如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。
- inline仅是一个对编译器的建议
- inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数
- 仅在定义时添加**inline**才可用，声明添加无效

### 类中的成员函数与inline
**定义**在类中的**成员函数**默认都是**内联的**，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。

### 函数重载
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型、顺序或者是否为常量 **const**）必须不同。您不能仅通过返回类型的不同来重载函数。

---
## 类与对象

#### 面向对象的基本特点

**抽象**：是指对于具体问题（对象）机型概括，抽出一类对象的公共性质并加以描述的过程。
	主要分为**数据抽象**和**行为抽象**（或称*功能抽象*、*代码抽象*）分别表示为变量名的命名及函数名的命名

**封装**：将抽象得到的数据和行为（或功能）相结合，形成一个有机整体，也就是将数据与操作数据分的函数代码进行有机结合，形成**类**，其中**数据**和**函数**都是类的成员

**继承**：允许在原有类的特性之上，进行更具体、更详细的说明

**多态**：是指一段程序能处理多种数据类型的能力可能通过强制多态、重载多态、类型参数化多态、包含多态来实现

#### 构造函数与析构函数

**默认构造函数**：调用时无需提供参数的构造函数，若类中没有定义则编译器会生成一个隐含的默认构造函数（参数和函数体皆为空）

**委托构造函数**：委托同类型的另一个构造函数对对象进行初始化。
比如
```c++
class Clock{
public:
	Clock(int a,int b,int c){}
	Clock(): Clock(0,0,0){}      //委托构造函数
}
```

**复制构造函数**：其形参是本类的一个**引用**，作用是使用一个已经存在过的对象，去初始化同类的一个新对象，
- 如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。
- 这个构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。
比如
```c++
#include<iostream>

class Point{
public:
	Point(int xx=0,int yy=0):x(xx),y(yy){}
	void display() { cout << "x:" << x << ",y:" << y << endl; }
	Point(Point& p) :x(p.x), y(p.y) { cout << "point reconstrcted" << endl; }
private:
    int x, y;
};

void display(Point p) { p.display(); }
Point build(int x, int y) { Point a(x, y); return a; }

int main() {
    Point a(1, 2);
    a.display();
    Point b(a);        //调用复制构造
    Point c = a;       //调用复制构造
	display(a);        //调用复制构造
	build(1, 2);       //调用复制构造
}
```
当不希望对象被复制构造时
- C++98做法：将复制构造函数声明为private，并且不提供函数的实现。
- C++11做法：用“=delete”指示编译器不生成默认复制构造函数。

**析构函数**：用来完成对象被删除前的一些清理工作，在对象生命周期即将结束时调用，且不接受任何函数，如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空。

#### UML图形表示

##### UML有三个基本的部分

- 事物（Things）  
	UML中重要的组成部分，在模型中属于最静态的部分，代表概念上的或物理上的元素

- 关系（Relationships）  
	关系把事物紧密联系在一起

- 图（Diagrams）  
	图是很多有相互相关的事物的组

以下是一个简单的 UML 类图的 Markdown 示例：

```mermaid
classDiagram
class Person {
  -name: String
  -age: int
  #aa: int
  +getAge(): int
  +setAge(age: int): void
  +getName(): String
  +setName(name: String): void
}
```
##### 几种关系表示

##### **依赖关系**
```mermaid
classDiagram 
direction LR
A ..> B
```
图中的“类A”是源，“类B”是目标，表示“类A”使用了“类B”，或称“类A”依赖“类B”

##### 作用关系——关联
```mermaid
classDiagram 
direction TB
类A "重数1"--"重数2" 类B
```
图中的“重数A”决定了类B的每个对象与类A的多少个对象发生作用，同样“重数B”决定了类A的每个对象与类B的多少个对象发生作用。

###### 包含关系——聚集和组合

**共享聚集**：部分可以参加多个整体
```mermaid
classDiagram 
direction LR
类A "重数1"--o"重数2" 类B
```
**组成聚集(组合)**：整体拥有各个部分，整体与部分共存，如果整体不存在了，那么部分也就不存在了。
```mermaid
classDiagram 
direction LR
类A "重数1"--*"重数2" 类B
```
**继承关系——泛化**
```mermaid
classDiagram 
direction TB
父类A <|-- 子类1
父类A <|-- 子类2
父类B <|-- 子类2
```

#### 联合体和结构体
###### 结构体
与类的唯一区别，结构体和类具有不同的默认访问控制属性
###### 联合体
访问控制属性与结构体相同，但全部数据成员共享一组内存单元
#### 小结
- **主要内容**
	- 面向对象的基本概念、类和对象的声明、构造函数、析构函数、内联成员函数、复制构造函数、类的组合
- **达到的目标**
	- 掌握面向对象的基本概念；
	- 掌握类设计的思想、类和对象声明的语法；
	- 理解构造函数、复制构造函数和析构函数的作用和调用过程，掌握相关的语法；
	- 理解内联成员函数的作用，掌握相关语法；
	- 理解类的组合在面向对象设计中的意义，掌握类组合的语法。