
其算法过程如下：
1. 输入皇后数量 N。
2. 分配一个长度为 N 的整型数组 M，用于存储每一行皇后所在的列数。
3. 调用 Q 函数，开始递归求解。
4. 在 Q 函数中，如果当前行数 r 等于 N，表示已经找到了一个可行的解，将解输出。
5. 否则，对于当前行 r，逐列进行尝试，如果当前列 c 满足不冲突的条件，即该列没有已经放置的皇后，且对角线上也没有皇后，将该列赋值给 M\[r\]，然后递归调用 Q 函数，继续搜索下一行。
6. 如果所有列都尝试完了，但仍然没有找到可行解，则递归结束，返回上一层。

其中，safe 函数用于判断当前列 c 是否安全，即该列没有已经放置的皇后，且对角线上也没有皇后。如果安全，返回 1，否则返回 0。这里采用的是遍历已经放置的皇后，判断是否与当前列 c 冲突的方法。如果存在冲突，即该皇后与当前皇后在同一列，或者在同一主对角线或次对角线上，则返回 0，否则返回 1。

```c
#include <stdio.h>
#include <stdlib.h>
int N, * M, cnt=0;
#define FOR(s,e) for (int s = 0; s < e; s++)
int safe(int r, int c) {
    FOR(i, r) if (M[i] == c || M[i] - i == c - r || M[i] + i == c + r)
        return 0;
    return 1;}
void Q(int r) { if (r == N) { cnt++ ;return;}
    FOR(c, N) if (safe(r, c)) { M[r] = c;Q(r + 1); }}
int main() {
    scanf("%d",&N);
    M = (int*)calloc(N, sizeof(int));
    Q(0);
}
```